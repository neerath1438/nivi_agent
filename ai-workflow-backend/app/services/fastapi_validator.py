"""
FastAPI Runtime Validator
Validates FastAPI projects by running uvicorn and testing endpoints.
"""
import os
import subprocess
import time
import logging
import requests
import psutil
from typing import Dict, Any, Optional, List

logger = logging.getLogger(__name__)

class FastAPIValidator:
    """
    Validates FastAPI projects by:
    1. Starting uvicorn server on port 8000
    2. Testing /docs endpoint (auto-generated by FastAPI)
    3. Testing custom health endpoint if available
    4. Capturing startup and runtime errors
    """
    
    def __init__(self, port: int = 8000, python_exe: Optional[str] = None):
        self.port = port
        self.process = None
        self.base_url = f"http://localhost:{port}"
        self.python_exe = python_exe or "python"
    
    def _find_available_port(self) -> int:
        """Find an available port starting from self.port."""
        import socket
        for port in range(self.port, self.port + 10):  # Try 8000-8009
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.bind(('localhost', port))
                    return port
            except OSError:
                continue
        return self.port  # Fallback to original
        
    def validate(self, project_path: str, max_wait: int = 60) -> Dict[str, Any]:
        """
        Validate a FastAPI project.
        
        Args:
            project_path: Absolute path to the FastAPI project directory
            max_wait: Maximum seconds to wait for server startup
            
        Returns:
            Dict with validation results:
            {
                "success": bool,
                "errors": List[str],
                "warnings": List[str],
                "server_running": bool,
                "endpoints_tested": List[str],
                "message": str
            }
        """
        errors = []
        warnings = []
        endpoints_tested = []
        
        try:
            # Step 1: Check if main.py or app.py exists
            main_file = self._find_main_file(project_path)
            if not main_file:
                return {
                    "success": False,
                    "errors": ["No main.py or app.py found in project"],
                    "warnings": [],
                    "server_running": False,
                    "endpoints_tested": [],
                    "message": "FastAPI entry point not found"
                }
            
            logger.info(f"[FASTAPI] Found entry point: {main_file}")
            
            # Step 2: Find available port and update base_url
            available_port = self._find_available_port()
            if available_port != self.port:
                logger.info(f"[FASTAPI] Port {self.port} busy, using port {available_port}")
                self.port = available_port
                self.base_url = f"http://localhost:{self.port}"
            
            # Step 3: Kill any existing process on the selected port
            self._kill_port_process(self.port)
            time.sleep(1)
            
            # Step 3.5: Pre-validate imports to catch errors early
            logger.info(f"[FASTAPI] Pre-validating imports...")
            import_valid, import_errors = self._validate_imports(project_path, main_file)
            
            if not import_valid:
                logger.warning(f"[FASTAPI] Import validation failed: {import_errors}")
                return {
                    "success": False,
                    "errors": import_errors,
                    "warnings": warnings,
                    "server_running": False,
                    "endpoints_tested": [],
                    "message": "Import validation failed - fix missing __init__.py or import paths",
                    "port": self.port,
                    "python_exe": self.python_exe
                }
            
            # Step 4: Start uvicorn server
            logger.info(f"[FASTAPI] Starting uvicorn on port {self.port}...")
            startup_success, startup_errors = self._start_server(project_path, main_file)
            
            if not startup_success:
                return {
                    "success": False,
                    "errors": startup_errors,
                    "warnings": warnings,
                    "server_running": False,
                    "endpoints_tested": [],
                    "message": "Server failed to start"
                }
            
            # Step 4: Wait for server to be ready
            logger.info(f"[FASTAPI] Waiting for server to be ready...")
            ready, ready_errors = self._wait_for_server(max_wait)
            
            if not ready:
                errors.extend(ready_errors)
                return {
                    "success": False,
                    "errors": errors,
                    "warnings": warnings,
                    "server_running": False,
                    "endpoints_tested": [],
                    "message": "Server did not become ready in time"
                }
            
            logger.info(f"[FASTAPI] Server is ready! Testing endpoints...")
            
            # Step 5: Test /docs endpoint (FastAPI auto-generates this)
            docs_success, docs_error = self._test_endpoint("/docs")
            if docs_success:
                endpoints_tested.append("/docs")
                logger.info("[FASTAPI] ✓ /docs endpoint working")
            else:
                errors.append(f"/docs endpoint failed: {docs_error}")
            
            # Step 6: Test /health endpoint if it exists
            health_success, health_error = self._test_endpoint("/health")
            if health_success:
                endpoints_tested.append("/health")
                logger.info("[FASTAPI] ✓ /health endpoint working")
            elif "404" not in str(health_error):
                # Only warn if it's not a 404 (404 means endpoint doesn't exist, which is okay)
                warnings.append(f"/health endpoint issue: {health_error}")
            
            # Step 7: Test root endpoint
            root_success, root_error = self._test_endpoint("/")
            if root_success:
                endpoints_tested.append("/")
                logger.info("[FASTAPI] ✓ / (root) endpoint working")
            elif "404" not in str(root_error):
                warnings.append(f"Root endpoint issue: {root_error}")
            
            # Determine overall success
            success = len(errors) == 0 and len(endpoints_tested) > 0
            
            message = "API working on port 8000" if success else "API has errors"
            
            return {
                "success": success,
                "errors": errors,
                "warnings": warnings,
                "server_running": True,
                "endpoints_tested": endpoints_tested,
                "message": message,
                "port": self.port,
                "base_url": self.base_url,
                "python_exe": self.python_exe
            }
            
        except Exception as e:
            logger.error(f"[FASTAPI] Validation exception: {str(e)}", exc_info=True)
            return {
                "success": False,
                "errors": [f"Validation exception: {str(e)}"],
                "warnings": warnings,
                "server_running": False,
                "endpoints_tested": endpoints_tested,
                "message": "Validation failed with exception"
            }
        finally:
            # Always cleanup
            self.cleanup()
    
    
    def _validate_imports(self, project_path: str, main_file: str) -> tuple[bool, List[str]]:
        """
        Pre-validate imports before starting server.
        Catches common import errors early:
        - Missing __init__.py files
        - Incorrect import paths
        - Module import failures
        
        Returns: (success, errors)
        """
        import sys
        errors = []
        
        # Check 1: All Python directories must have __init__.py
        for root, dirs, files in os.walk(project_path):
            # Skip __pycache__ and hidden directories
            dirs[:] = [d for d in dirs if not d.startswith('.') and d != '__pycache__']
            
            # If directory contains .py files (excluding __pycache__)
            py_files = [f for f in files if f.endswith('.py') and f != '__pycache__']
            if py_files and '__init__.py' not in files:
                rel_path = os.path.relpath(root, project_path)
                if rel_path != '.':  # Skip root directory
                    errors.append(f"Missing __init__.py in directory: {rel_path}/")
        
        # Check 2: Try importing the main module
        original_path = sys.path.copy()
        try:
            # Add project path to sys.path temporarily
            if project_path not in sys.path:
                sys.path.insert(0, project_path)
            
            # Try to import the main module using the specified python_exe if it's not the current one
            module_name = main_file.replace('/', '.').replace('\\', '.')
            
            # If using a custom python_exe, we should probably run a small script instead of __import__
            # in the current process, because the current process might have different packages.
            if self.python_exe != "python" and self.python_exe != sys.executable:
                logger.info(f"[FASTAPI] Validating imports using external python: {self.python_exe}")
                check_script = f"import sys; sys.path.insert(0, r'{project_path}'); import {module_name}; print('SUCCESS')"
                try:
                    res = subprocess.run(
                        [self.python_exe, "-c", check_script],
                        capture_output=True, text=True, timeout=15
                    )
                    if res.returncode == 0 and "SUCCESS" in res.stdout:
                        logger.info(f"[FASTAPI] External import validation passed")
                        return True, []
                    else:
                        errors.append(f"External Import Error (using {self.python_exe}):")
                        errors.append(res.stderr.strip() or res.stdout.strip())
                        return False, errors
                except Exception as e:
                    errors.append(f"Failed to run external import check: {str(e)}")
                    return False, errors

            try:
                __import__(module_name)
                logger.info(f"[FASTAPI] Successfully imported {module_name}")
            except ImportError as e:
                error_msg = str(e)
                # Provide helpful suggestions
                if "No module named" in error_msg:
                    errors.append(f"Import Error: {error_msg}")
                    errors.append("Common fixes:")
                    errors.append("  1. Add missing __init__.py files in all directories")
                    errors.append("  2. Use correct import paths: 'from app.api.v1.users' not 'from api.v1.users'")
                    errors.append("  3. Check for typos in import statements")
                else:
                    errors.append(f"Import Error: {error_msg}")
            except Exception as e:
                errors.append(f"Module Error: {type(e).__name__}: {str(e)}")
                
        finally:
            # Restore original sys.path
            sys.path = original_path
            
            # Clean up imported modules to avoid conflicts
            modules_to_remove = [m for m in sys.modules.keys() if m.startswith(main_file.split('.')[0])]
            for mod in modules_to_remove:
                try:
                    del sys.modules[mod]
                except:
                    pass
        
        return len(errors) == 0, errors
    
    def _find_main_file(self, project_path: str) -> Optional[str]:
        """Find the main FastAPI entry point (main.py or app.py), including in subdirectories."""
        # First check root directory
        for filename in ["main.py", "app.py", "api.py"]:
            filepath = os.path.join(project_path, filename)
            if os.path.exists(filepath):
                return filename.replace(".py", "")
        
        # Check common subdirectories (app/, src/, api/)
        for subdir in ["app", "src", "api"]:
            for filename in ["main.py", "app.py", "api.py"]:
                filepath = os.path.join(project_path, subdir, filename)
                if os.path.exists(filepath):
                    # Return module path like "app.main"
                    return f"{subdir}.{filename.replace('.py', '')}"
        
        # Recursive search as last resort
        for root, dirs, files in os.walk(project_path):
            for filename in ["main.py", "app.py", "api.py"]:
                if filename in files:
                    # Get relative path from project_path
                    rel_path = os.path.relpath(os.path.join(root, filename), project_path)
                    # Convert to module path: app/main.py -> app.main
                    module_path = rel_path.replace(os.sep, ".").replace(".py", "")
                    return module_path
        
        return None
    
    def _kill_port_process(self, port: int):
        """Kill any process using the specified port."""
        try:
            for proc in psutil.process_iter(['pid', 'name']):
                try:
                    # Get connections for this process
                    connections = proc.connections()
                    for conn in connections:
                        if hasattr(conn, 'laddr') and conn.laddr.port == port:
                            logger.info(f"[FASTAPI] Killing process {proc.pid} using port {port}")
                            proc.kill()
                            time.sleep(1)
                            break
                except (psutil.NoSuchProcess, psutil.AccessDenied, AttributeError):
                    # Process may have terminated or we don't have permission
                    pass
        except Exception as e:
            logger.warning(f"[FASTAPI] Could not kill port process: {e}")
    
    def _start_server(self, project_path: str, main_file: str) -> tuple[bool, List[str]]:
        """Start the uvicorn server and capture logs."""
        errors = []
        try:
            # Command: uvicorn main:app --port 8000 --reload
            # Use the specified python_exe to run uvicorn as a module
            cmd = [
                self.python_exe,
                "-m", "uvicorn",
                f"{main_file}:app",
                "--port", str(self.port),
                "--reload"
            ]
            
            logger.info(f"[FASTAPI] Running: {' '.join(cmd)}")
            
            # Create log file for server output
            import tempfile
            self.log_file = tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix='.log', encoding='utf-8')
            
            # Start process with output redirected to log file
            self.process = subprocess.Popen(
                cmd,
                cwd=project_path,
                stdout=self.log_file,
                stderr=subprocess.STDOUT,  # Merge stderr into stdout
                text=True,
                bufsize=1
            )
            
            # Give it a moment to start
            time.sleep(3)
            
            # Check if process is still running
            if self.process.poll() is not None:
                # Process died - read logs
                self.log_file.flush()
                self.log_file.seek(0)
                log_content = self.log_file.read()
                
                errors.append(f"Server crashed on startup")
                if log_content:
                    errors.append(f"Server logs:\n{log_content[:1000]}")  # First 1000 chars
                return False, errors
            
            return True, []
            
        except FileNotFoundError:
            errors.append("uvicorn not found. Install with: pip install uvicorn")
            return False, errors
        except Exception as e:
            errors.append(f"Failed to start server: {str(e)}")
            return False, errors
    
    def _wait_for_server(self, max_wait: int) -> tuple[bool, List[str]]:
        """Wait for server to be ready by polling /docs endpoint."""
        errors = []
        start_time = time.time()
        
        while time.time() - start_time < max_wait:
            try:
                response = requests.get(f"{self.base_url}/docs", timeout=2)
                if response.status_code == 200:
                    return True, []
            except requests.exceptions.RequestException:
                pass
            
            # Check if process died
            if self.process and self.process.poll() is not None:
                # Server crashed - read logs
                errors.append("Server process died during startup")
                
                # Read log file for detailed error
                if hasattr(self, 'log_file'):
                    try:
                        self.log_file.flush()
                        self.log_file.seek(0)
                        log_content = self.log_file.read()
                        if log_content:
                            errors.append(f"Server logs:\n{log_content[:5000]}")  # First 5000 chars for full traceback
                    except Exception as e:
                        errors.append(f"Could not read log file: {e}")
                
                return False, errors
            
            time.sleep(1)
        
        # Timeout - read logs anyway to see what's happening
        errors.append(f"Server did not respond within {max_wait} seconds")
        
        if hasattr(self, 'log_file'):
            try:
                self.log_file.flush()
                self.log_file.seek(0)
                log_content = self.log_file.read()
                if log_content:
                    errors.append(f"Server logs (timeout):\n{log_content[:5000]}")  # Increased for full error context
            except Exception as e:
                errors.append(f"Could not read log file: {e}")
        
        return False, errors
    
    def _test_endpoint(self, endpoint: str) -> tuple[bool, Optional[str]]:
        """Test a single endpoint."""
        try:
            url = f"{self.base_url}{endpoint}"
            response = requests.get(url, timeout=5)
            
            if response.status_code == 200:
                return True, None
            else:
                return False, f"Status {response.status_code}"
                
        except requests.exceptions.RequestException as e:
            return False, str(e)
    
    def cleanup(self):
        """Stop the server and cleanup resources."""
        if self.process:
            try:
                logger.info("[FASTAPI] Stopping uvicorn server and its process tree...")
                parent = psutil.Process(self.process.pid)
                # Kill children first (uvicorn --reload starts children)
                for child in parent.children(recursive=True):
                    try:
                        child.kill()
                    except: pass
                parent.kill()
                self.process.wait(timeout=2)
            except Exception as e:
                logger.debug(f"[FASTAPI] Cleanup error: {e}")
            finally:
                self.process = None
        
        # Close and remove log file
        if hasattr(self, 'log_file'):
            try:
                # Ensure file is closed and flushed
                if not self.log_file.closed:
                    self.log_file.flush()
                    self.log_file.close()
                
                # Wait a bit for Windows to release the file handle
                time.sleep(0.5)
                
                # Try to remove with retry (Windows file locking)
                import os
                if os.path.exists(self.log_file.name):
                    for attempt in range(3):
                        try:
                            os.remove(self.log_file.name)
                            logger.info("[FASTAPI] Log file removed successfully")
                            break
                        except PermissionError:
                            if attempt < 2:
                                time.sleep(0.5)  # Wait and retry
                            else:
                                # Silent fail on last attempt - file will be cleaned by OS temp cleanup
                                logger.debug(f"[FASTAPI] Log file will be cleaned by OS: {self.log_file.name}")
            except Exception as e:
                # Don't warn - this is expected on Windows sometimes
                logger.debug(f"[FASTAPI] Log file cleanup: {e}")
        
        # Final port cleanup
        self._kill_port_process(self.port)
